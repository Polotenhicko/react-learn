import React from 'react';
// Перенаправление рефов позволяет автоматически передавать реф компонента одному из его дочерних элементов
// Большинству компонентов перенаправление рефов не нужно, но оно может быть полезно, например, если вы пишете библиотеку

// Перенаправление рефов в DOM-компоненты

// Допустим, у нас есть компонент FancyButton, который рендерит нативный DOM-элемент button:
let FancyButton = function FancyButton(props) {
  return <button className="FancyButton">{props.children}</button>;
};

// React-компоненты скрывают свои детали реализации, в том числе результат рендеринга.

// Реф элемента button из FancyButton обычно и не требуется другим компонентам.
// Это хорошо, поскольку такой подход не даёт компонентам излишне полагаться на структуру DOM друг друга.

// Такая инкапсуляция хорошо подходит компонентам, которые описывают некую законченную часть приложения, например, FeedStory или Comment

// А вот в «маленьких», часто повторно используемых компонентах, таких как FancyButton или MyTextInput, она может быть неудобной.
// Чтобы управлять фокусом, выделением и анимациями этих компонентов, придётся получить доступ к их DOM - узлам.

// Перенаправление рефов позволяет взять ref из атрибутов компонента, и передать («перенаправить») его одному из дочерних компонентов.

// В данном примере мы используем React.forwardRef в компоненте FancyButton, чтобы получить реф и передать его в дочерний
// DOM - элемент button.

FancyButton = React.forwardRef((props, ref) => (
  <button ref={ref} className="FancyButton">
    {props.children}
  </button>
));

const ref = React.createRef();
<FancyButton ref={ref}>Click me!</FancyButton>;

// Таким образом, когда мы будем применять FancyButton в других компонентах,
// мы сможем получить реф находящегося в нём DOM - узла button и использовать его так же,
//  как если бы мы рендерили непосредственно button.

// Рассмотрим этот пример пошагово:

// Мы создаём реф, вызвав React.createRef и записываем его в переменную ref.
// Мы передаём переменную ref в <FancyButton ref={ref}>, указывая её в JSX-атрибуте.
// React передаёт ref в функцию (props, ref) => ... внутри forwardRef в качестве второго аргумента.
// Мы передаём аргумент ref дальше в <button ref={ref}>, указывая его в JSX-атрибуте.
// После привязки рефа ref.current будет указывать на DOM-узел <button>.

// Перенаправить реф можно не только в DOM-компонент, но и в экземпляр классового компонента.

// дальше теория про компоненты высшего порядка, но я не изучал их пока что, так что пропущу

// Изменение названия в инструментах разработки

// В React.forwardRef передаётся функция рендеринга. Эта функция определяет, как будет называться компонент в инструментах разработки.

// Например, вот этот компонент будет называться «ForwardRef»:
// у меня вылезает ошибка, хз почему, но вроде имя как указано, есть
// FancyButton = React.forwardRef((props, ref) => {
//   return <button {...props} forwardedRef={ref} />;
// });

// теперь появилось название
FancyButton = React.forwardRef(function Naming(props, ref) {
  return (
    <button ref={ref} className="FancyButton">
      {props.children}
    </button>
  );
});

// Можно даже назначить функции свойство displayName и указать в нём, какой именно компонент обёрнут в HOC:
// но снова, я хз чё такое НОС, не дошёл

export { FancyButton };

// как я понял, это нужно для функциональных компонентов, а те в свою очередь, содержат классовый компонент
// и это всё называется НОС

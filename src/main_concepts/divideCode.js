import { lazy } from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
// бандлинг - процесс выявления импортированных файлов и объединения их в один «собранный» файл
// Этот бандл после подключения на веб-страницу загружает всё приложение за один раз.

// Если вы используете Create React App, Next.js, Gatsby или похожие инструменты,
//  то у вас уже будет настроенный Webpack для бандлинга приложения.

// Чтобы предотвратить разрастание бандла, стоит начать «разделять» ваш бандл.
// Хоть вы и не уменьшите общий объём кода вашего приложения, но избежите загрузки кода,
// который может никогда не понадобиться пользователю и уменьшите объём кода, необходимый для начальной загрузки.

// Лучший способ внедрить разделение кода в приложение — использовать синтаксис динамического импорта: import().

// До:
// import { add } from './math';

// console.log(add(16, 26));

// После:
// import('./math').then((math) => {
//   console.log(math.add(16, 26));
// });

// Когда Webpack сталкивается с таким синтаксисом, он автоматически начинает разделять код вашего приложения
// Если вы используете Create React App, то всё уже настроено и вы можете сразу начать использовать
// синтаксис динамического импорта.Он также поддерживается «из коробки» в Next.js.

// Функция React.lazy позволяет рендерить динамический импорт как обычный компонент.

// До:
// import OtherComponent from './OtherComponent';
// После:
// const OtherComponent = React.lazy(() => import('./OtherComponent'));

// Она автоматически загрузит бандл, содержащий OtherComponent, когда этот компонент будет впервые отрендерен.
// React.lazy принимает функцию, которая должна вызвать динамический import().
// Результатом возвращённого Promise является модуль, который экспортирует по умолчанию React-компонент
// (export default).

// Компонент с ленивой загрузкой должен рендериться внутри компонента Suspense,
import React, { Suspense } from 'react';

const OtherComponent = React.lazy(() => import('./OtherComponent'));
function MyComponent() {
  return (
    <div>
      {/* Проп fallback принимает любой React-элемент, который вы хотите показать, 
      // пока происходит загрузка компонента */}
      <Suspense fallback={<div>Загрузка...</div>}>
        <OtherComponent />
      </Suspense>
    </div>
  );
}
// Компонент Suspense можно разместить в любом месте над ленивым компонентом
// Кроме того, можно обернуть несколько ленивых компонентов одним компонентом Suspense.

const OtherComponent2 = React.lazy(() => import('./OtherComponent'));
const AnotherComponent = React.lazy(() => import('./OtherComponent'));

function MyComponent2() {
  return (
    <div>
      <Suspense fallback={<div>Загрузка...</div>}>
        <section>
          <OtherComponent2 />
          <AnotherComponent />
        </section>
      </Suspense>
    </div>
  );
}

// Любой компонент может приостановиться в результате рендеринга,
//  даже компоненты, которые уже были показаны пользователю

// Чтобы содержимое экрана всегда было согласованным, если уже показанный компонент приостанавливается,
//  React должен скрыть его дерево до ближайшей < Suspense > границы.
// Однако с точки зрения пользователя это может дезориентировать.

// Если какой-то модуль не загружается (например, из-за сбоя сети), это вызовет ошибку.
// Вы можете обрабатывать эти ошибки для улучшения пользовательского опыта с помощью Предохранителей.
// После создания предохранителя, его можно использовать в любом месте над ленивыми компонентами
// для отображения состояния ошибки.

// Пока я хуй знает что это
const OtherComponent3 = React.lazy(() => import('./OtherComponent'));
const AnotherComponent3 = React.lazy(() => import('./OtherComponent'));
const MyErrorBoundary = React.lazy(() => import('./OtherComponent'));

const MyComponent3 = () => (
  <div>
    <MyErrorBoundary>
      <Suspense fallback={<div>Загрузка...</div>}>
        <section>
          <OtherComponent />
          <AnotherComponent />
        </section>
      </Suspense>
    </MyErrorBoundary>
  </div>
);

// Решение о том, где в вашем приложении ввести разделение кода, может быть непростым
// В идеале, следует выбрать такие места, чтобы код разделялся на бандлы примерно одного размера
// Часто таким удобным местом оказываются маршруты

// Большинство интернет-пользователей привыкли к задержкам во время переходов между страницами.
// Поэтому и вам может быть выгодно повторно отрендерить всю страницу целиком

// Это не позволит пользователям взаимодействовать с другими элементами на странице, пока происходит обновление.
// Вот пример того, как организовать разделение кода на основе маршрутов с помощью React.lazy
// и таких библиотек как React Router.

const Home = lazy(() => import('./OtherComponent'));
const About = lazy(() => import('./OtherComponent'));

const App = () => (
  <Router>
    <Suspense fallback={<div>Loading...</div>}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
    </Suspense>
  </Router>
);

// React.lazy в настоящее время поддерживает только экспорт по умолчанию
//  Если модуль, который требуется импортировать, использует именованный экспорт,
//  можно создать промежуточный модуль, который повторно экспортирует его как модуль по умолчанию
// Это гарантирует работоспособность tree shaking — механизма устранения неиспользуемого кода.

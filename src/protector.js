// Предохранители
// Ранее ошибки JavaScript внутри компонентов портили внутреннее состояние React и заставляли
// его выдавать таинственные сообщения об ошибках во время следующего рендера
// Эти сообщения всегда вызывались ошибками, расположенными где-то выше в коде приложения,
// но React не предоставлял способа адекватно обрабатывать их в компонентах и не мог обработать их самостоятельно.

// Ошибка JavaScript где-то в коде UI не должна прерывать работу всего приложения.
// Чтобы исправить эту проблему для React - пользователей, React 16 вводит концепцию «предохранителя» (error boundary).

// Предохранители — это компоненты React, которые отлавливают ошибки JavaScript в любом месте деревьев их дочерних компонентов,
//  сохраняют их в журнале ошибок и выводят запасной UI вместо рухнувшего дерева компонентов.

// Предохранители отлавливают ошибки при рендеринге, в методах жизненного цикла и конструкторах деревьев компонентов,
// расположенных под ними.

// Предохранители не поймают ошибки в:

// обработчиках событий; типа функций коллбэка для событий, там можно try/catch
// асинхронном коде (например колбэках из setTimeout или requestAnimationFrame);
// серверном рендеринге (Server-side rendering); что ето
// самом предохранителе (а не в его дочерних компонентах).

// Классовый компонент является предохранителем, если он включает хотя бы один из следующих методов жизненного цикла:
// static getDerivedStateFromError() или componentDidCatch()

let ErrorBoundary = class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false,
    };
  }

  static getDerivedStateFromError(error) {
    // обновить состояние с тем, чтобы след рендер показал запасной UI
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // можно сохранить сообщение об ошибке в службу журнала ошибок
    logErrorToMyService(error, errorInfo); // это существующая функция в реакте?
  }

  render() {
    if (this.state.hasError) {
      // можно отрендерить запасной UI произвольного кода
      return <h1>Всё полетело</h1>;
    }
    // или отрендерить что внутри
    return this.props.children;
  }
};

// И можно дальше им пользоваться, как обыкновенным компонентом:

<ErrorBoundary>
  <MyWidget />
</ErrorBoundary>;

// Предохранители работают как JavaScript-блоки catch {}, но только для компонентов.
// Только классовые компоненты могут выступать в роли предохранителей
// Советуют 1 раз написать предохранитель и дальше использовать его по всему приложению

// Предохранитель не сможет отловить ошибку внутри самого себя

// Если предохранителю не удаётся отрендерить сообщение об ошибке, то ошибка всплывает до ближайшего предохранителя,
// расположенного над ним в дереве компонентов

// реализация идёт на усмотрение

// Начиная с React 16, ошибки, не отловленные ни одним из предохранителей,
// будут приводить к размонтированию всего дерева компонентов React.

// В режиме разработки React 16 выводит на консоль сообщения обо всех ошибках,
// возникших при рендеринге, даже если они никак не сказались на работе приложения.

// Имена компонентов, выводимые в их стеке вызовов, определяются свойством Function.name.

// try / catch — отличная конструкция, но она работает исключительно в императивном коде:
// В то время, как компоненты React являются декларативными, указывая что должно быть отрендерено:
// Предохранители сохраняют декларативную природу React и ведут себя так, как вы уже привыкли ожидать от компонентов React

// Предохранители не отлавливают ошибки, произошедшие в обработчиках событий.
// Чтобы отловить ошибку в обработчике событий, пользуйтесь обычной JavaScript-конструкцией try / catch:

// React 15 включал очень ограниченную поддержку предохранителей с другим названием метода: unstable_handleError.
// Этот метод больше не работает и вам нужно будет заменить его на componentDidCatch в своем коде,
// начиная с первого бета - релиза React 16.

// для автоматической замены есть спец код

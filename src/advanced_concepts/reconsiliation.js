// Если бы мы использовали O(n^3) в React, отображение 1000 элементов потребовало бы порядка миллиарда сравнений.
// Это слишком дорого. Взамен, React реализует эвристический алгоритм O(n), который основывается на двух утверждениях:

// 1. Два элемента с разными типами произведут разные деревья.
// 2. Разработчик может указать какие дочерние элементы останутся стабильными между рендерами с помощью пропа key.

// React сравнивает деревья начиная с их корневых элементов и направляется вниз. Сравниваются типы (теги) корневых элементов.
// Всякий раз, когда корневые элементы имеют различные типы, React уничтожает старое дерево и строит новое с нуля
// Трансформация из <a> в <img>, или из <Article> в <Comment>, или из <Button> в <div> приведут к полному перестроению вложенных элементов.

// При уничтожении дерева старые DOM-узлы удаляются. Экземпляры компонента получают componentWillUnmount()

// При построении нового дерева, новые DOM-узлы вставляются в DOM. Экземпляры компонента получают UNSAFE_componentWillMount(),
// а затем componentDidMount().Любое состояние, связанное со старым деревом, теряется.
// Любые компоненты, лежащие ниже корневого, также размонтируются, а их состояние уничтожится.

// При сравнении двух React DOM-элементов одного типа, React смотрит на атрибуты обоих, сохраняет лежащий в основе этих
// элементов DOM-узел и обновляет только изменённые атрибуты. Например:

<div className="before" title="stuff" />;
// поменяется
<div className="after" title="stuff" />;
// Сравнивая эти элементы, React знает, что нужно модифицировать только className у DOM-узла.

// Обновляя style, React также знает, что нужно обновлять только изменившиеся свойства. Например:
<div style={{ color: 'red', fontWeight: 'bold' }} />;
// поменяется
<div style={{ color: 'green', fontWeight: 'bold' }} />;
// При конвертации между этими элементами, React знает, что нужно модифицировать только стиль color, не затронув fontWeight.

// Когда компонент обновляется, его экземпляр остаётся прежним, поэтому его состояние сохраняется между рендерами
//  React обновляет пропсы базового экземпляра компонента для соответствия новому элементу и вызывает
// UNSAFE_componentWillReceiveProps(), UNSAFE_componentWillUpdate и componentDidUpdate() на базовом экземпляре.

// По умолчанию при рекурсивном обходе дочерних элементов DOM-узла React одновременно проходит по обоим спискам потомков
// и создаёт мутацию, когда находит отличие.

// Например, при добавлении элемента в конец дочерних элементов, преобразование между этими деревьями работает отлично:
<ul>
  <li>первый</li>
  <li>второй</li>
</ul>;

<ul>
  <li>первый</li>
  <li>второй</li>
  <li>третий</li>
</ul>;

// React сравнит два дерева <li>первый</li>, сравнит два дерева <li>второй</li>, а затем вставит дерево <li>третий</li>.
// При вставке элемента в начало, прямолинейная реализация такого алгоритма будет работать не эффективно

<ul>
  <li>Санкт-Петербург</li>
  <li>Москва</li>
</ul>;

<ul>
  <li>Ростов-на-Дону</li>
  <li>Санкт-Петербург</li>
  <li>Москва</li>
</ul>;

// React, вместо того чтобы оставить <li>Санкт-Петербург</li>  и <li>Москва</li> нетронутыми, будет мутировать каждого потомка.
// Эта неэффективность может стать проблемой.

// Чтобы решать такие проблемы придумали ключи

<ul>
  <li key="2015">Санкт-Петербург</li>
  <li key="2016">Москва</li>
</ul>;

<ul>
  <li key="2014">Ростов-на-Дону</li>
  <li key="2015">Санкт-Петербург</li>
  <li key="2016">Москва</li>
</ul>;

// Теперь React знает, что элемент с ключом '2014' — новый, а элементы с ключами '2015' и '2016' переместились.

// ключ обычно - уникальный id
// в крайнем случае - индекс если массив никогда не поменяется
//  Если ключ является индексом, то перемещение элемента изменяет его

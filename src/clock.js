import React from "react";

let Clock = function Clock(props) {
	return (
		<div>
			<h1>Привет!</h1>
			<h2>Сейчас {props.date.toLocaleTimeString()}</h2>
		</div>
	);
};

// преобразуем функциональный компонент в классовый
// указываем в родители React.Component
// добавляем в класс метод render()
// переносим тело функции в render()
// заменяем props на this.props

Clock = class Clock extends React.Component {
	render() {
		return (
			<div>
				<h1>Привет!</h1>
				<h2>Сейчас {this.props.date.toLocaleTimeString()}</h2>
			</div>
		);
	}
};

// теперь Clock определён как класс
// метод render будет вызыватсья каждый раз, когда происходит обновление.
// т.к. мы рендерим Clock в один и тот же DOM-контейнер, мы используем единственный эклезмпляр класса Clock
// поэтому мы можем задействовать внутреннее состояние и методы жизненного цикла

// переместим date из пропсов в состояния

// заменим this.props.date на this.state.date в render()

Clock = class Clock extends React.Component {
	// в конструктор класса указываем начальное состояние в переменную this.state
	constructor(props) {
		super(props);
		this.state = { date: new Date() };
	}
	// далее удаляем prop date из <Clock />
	render() {
		return (
			<div>
				<h1>Привет!</h1>
				<h2>Сейчас {this.state.date.toLocaleTimeString()}</h2>
			</div>
		);
	}
};

// в приложениях со множеством компонентов очень важно освобождать используемые системные ресурсы когда компоненты удаляются
// первоначальный рендеринг называется монтирование (mounting). Нам нужно установить таймер всякий раз, когда это происходит
// Каждый раз когда DOM-узел, созданный компонентом, удаляется, происходит «размонтирование» (unmounting).
//  Чтобы избежать утечки ресурсов, мы будем сбрасывать таймер при каждом «размонтировании».

// объявим специальные методы для монтирования и размонтирования
Clock = class Clock extends React.Component {
	// в конструктор класса указываем начальное состояние в переменную this.state
	constructor(props) {
		// поля this.props и this.state устанавливает сам Реакт
		super(props);
		this.state = { date: new Date() };
	}
	// эти методы называются "методами жизненного цикла"
	componentDidMount() {
		// запускается после того, как компонент отрендерился в DOM, здесь мы и установим таймер
		this.timerId = setInterval(() => this.tick(), 1e3);
	}

	componentWillUnmount() {
		// сбрасываем таймер в методе жизненного цикла
		clearInterval(this.timerId);
	}

	// реализуем метод tick(). Он запускается таймером каждую секунду и вызывает this.setState()
	// this.setState() планирует обновление внутреннего состояния компонента
	tick() {
		this.setState({
			date: new Date(),
		});
	}

	// далее удаляем prop date из <Clock />
	render() {
		return (
			<div>
				<h1>Привет!</h1>
				<h2>Сейчас {this.state.date.toLocaleTimeString()}</h2>
			</div>
		);
	}
};

// Когда мы передаём <Clock /> в root.render(), React вызывает конструктор компонента.
// Clock должен отображать текущее время, поэтому мы задаём начальное состояние this.state объектом
// с текущим временем.Позже мы обновим это состояние.

// React вызывает метод render() компонента Clock. Таким образом React узнаёт,
// что отобразить на экране.Далее React обновляет DOM так, чтобы он соответствовал выводу рендера Clock.

// Как только вывод рендера Clock вставлен в DOM, React вызывает метод жизненного цикла componentDidMount().
// Внутри него компонент Clock указывает браузеру установить таймер, который будет вызывать tick() раз в секунду.

// Таймер вызывает tick() ежесекундно. Внутри tick() мы просим React обновить состояние компонента,
// вызывая setState() с текущим временем.React реагирует на изменение состояния и снова запускает render().
// На этот раз this.state.date в методе render() содержит новое значение, поэтому React заменит DOM.
// Таким образом компонент Clock каждую секунду обновляет UI.

// Если компонент Clock когда-либо удалится из DOM, React вызовет метод жизненного цикла componentWillUnmount() и сбросит таймер.

// !!! не изменять состояние напрямую
// this.state.comment = 'Тест'
// вместо этого нужно использовать this.setState({comment: 'Тест'})
// конструктор - единственное место, где можно присвоить значение this.state напрямую

// Реакт может сгруппировать несколько вызовов setState() в одно объявление для улучшения производительности
// this.props и this.state могут обновляться асинхронно, нельзя полагаться на их текущее значение для вычисления след состояния

// к примеру след код может не обновить счётчик

// this.setState({
// 	counter: this.state.counter + this.props.increment,
// });

// правильней будет использовать 2 вариант вызова setState, который принимает функцию, а не объект
// эта функция получит предыдущее состояние в качестве первого аргумента
// и значение пропсов непосредственно во время обновления в качестве второго аргумента

// правильно
// this.setState((state, props) => ({
//   counter: state.counter + props.increment
// }));

// можно и так
// this.setState(function (state, props) {
// 	return {
// 		counter: state.counter + props.increment,
// 	};
// });

export { Clock };
